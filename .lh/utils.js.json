{
    "sourceFile": "utils.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1727823578454,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1727823578454,
            "name": "Commit-0",
            "content": "export const sel = (e) => document.querySelector(e)\r\nexport const selAll = (e) => document.querySelectorAll(e)\r\nexport const vh = (percent) => window.innerHeight * (percent / 100)\r\nexport const vw = (percent) => window.innerWidth * (percent / 100)\r\nexport const mm = gsap.matchMedia()\r\n\r\nexport const isDomEl = (el) => el instanceof Document || el instanceof Element\r\nexport const l = (...e) => console.debug(...e)\r\n\r\nexport function selector(el) {\r\n  if (isDomEl(el)) return el\r\n\r\n  if (typeof el === 'string' && el.charAt(0) !== '.' && el.charAt(0) !== '[' && el.charAt(0) !== '#' && el.length > 1) el = '.' + el\r\n\r\n  return document.querySelector(el)\r\n}\r\n\r\n// export function debounce(func, time = 100) {\r\n//   let timer = 0\r\n//   return function (event) {\r\n//     if (timer) clearTimeout(timer)\r\n//     timer = setTimeout(func, time, event)\r\n//   }\r\n// }\r\nexport function debounce(func, timeout = 100) {\r\n  let timer\r\n  return (...args) => {\r\n    clearTimeout(timer)\r\n    timer = setTimeout(() => {\r\n      func.apply(this, args)\r\n    }, timeout)\r\n  }\r\n}\r\nexport function devMode(mode) {\r\n  if (mode === 0) {\r\n    return\r\n  } else if (mode === 1) {\r\n    let i = 0\r\n    document.querySelectorAll('[data-video-urls]').forEach((el) => {\r\n      el.querySelector('video').remove()\r\n      i++\r\n    })\r\n    console.log('devMode, removed videos:', i)\r\n  } else if (mode === 2) {\r\n    const devRemoveList = []\r\n    // const devRemoveList = [videoHero$, introSec$, aboutSec$]\r\n    devRemoveList.forEach((el) => {\r\n      el.remove()\r\n    })\r\n    console.log('devMode: removing sections')\r\n  }\r\n}\r\n\r\nexport function removeSplideClasses(el) {\r\n  const splide = selector(el)\r\n  const track = splide.querySelector('.splide__track')\r\n  const list = splide.querySelector('.splide__list')\r\n  const slide = splide.querySelectorAll('.splide__slide')\r\n  splide.classList.remove('splide')\r\n  track.classList.remove('splide__track')\r\n  list.classList.remove('splide__list')\r\n  slide.forEach((slide) => slide.classList.remove('splide__slide'))\r\n}\r\nexport function addSplideClasses(el, trackClass = '') {\r\n  let splide = selector(el)\r\n  // const track = splide.children[0]\r\n  // const track = splide.querySelector('.w-dyn-list')\r\n  const track = trackClass === '' ? splide.querySelector('.w-dyn-list') : splide.querySelector(trackClass)\r\n\r\n  const list = track.querySelector('.w-dyn-items')\r\n  const slide = list.childNodes\r\n\r\n  splide.classList.add('splide')\r\n  track.classList.add('splide__track')\r\n  list.classList.add('splide__list')\r\n  slide.forEach((slide) => slide.classList.add('splide__slide'))\r\n}\r\n\r\nexport function addStaticSplideClasses(el) {\r\n  let splide = selector(el)\r\n  const track = splide.firstChild\r\n  const list = track.firstChild\r\n  const slide = list.childNodes\r\n\r\n  splide.classList.add('splide')\r\n  track.classList.add('splide__track')\r\n  list.classList.add('splide__list')\r\n  slide.forEach((slide) => slide.classList.add('splide__slide'))\r\n}\r\n\r\n/*\r\n * @param {Object} splide - The Splide instance.\r\n * @param {string} arrowW - The selector or element of the wrapper containing the arrows.\r\n * @param {string} [_arrow='.arrow'] - The selector for the arrow elements (optional, default is '.arrow').\r\n */\r\nexport function connectSplideArrows(splide, arrowW, _arrow = '.arrow') {\r\n  // if (!splide.length) return console.log('splide not found/mounted', splide)\r\n  const arrowW$ = selector(arrowW)\r\n  const leftArrow$ = arrowW$.querySelector(_arrow + '.is--left')\r\n  const rightArrow$ = arrowW$.querySelector(_arrow + ':not(.is--left)')\r\n  if (!leftArrow$ || !rightArrow$) return console.log('arrows not found', 'left:', leftArrow$, 'right:', rightArrow$, 'in wrapper:', arrowW$, 'slide:', splide)\r\n\r\n  arrowW$.style.overflow = 'hidden'\r\n\r\n  const pages = Math.ceil(splide.length / splide.options.perPage)\r\n\r\n  if (pages > 1) {\r\n    arrowW$.style.maxHeight = 'revert-layer' // to get the initial css value\r\n\r\n    leftArrow$.addEventListener('pointerdown', function () {\r\n      splide.go('<')\r\n    })\r\n    rightArrow$.addEventListener('pointerdown', function () {\r\n      splide.go('>')\r\n    })\r\n  } else {\r\n    // keep the dom elements to repopulate in the future\r\n    arrowW$.style.maxHeight = '0px'\r\n  }\r\n}\r\nexport function connectSplideBullets(splide, el) {\r\n  // parse bullets inside the container and repopulate\r\n  const pagination$ = selector(el)\r\n\r\n  let bulletPressed = false\r\n\r\n  if (splide.length > 1) {\r\n    const bullet$ = pagination$.querySelector('.bullet:not(.is--active)')\r\n    let fragment = document.createDocumentFragment()\r\n    for (let i = 0; i < splide.length; i++) {\r\n      let clone$ = bullet$.cloneNode(true)\r\n      clone$.addEventListener('click', (e) => {\r\n        bulletPressed = true\r\n        splide.go(i)\r\n      })\r\n      fragment.appendChild(clone$)\r\n    }\r\n    fragment.firstChild.classList.add('is--active')\r\n    pagination$.replaceChildren(fragment)\r\n  } else {\r\n    pagination$.replaceChildren()\r\n  }\r\n  splide.on('move', function (newIndex, oldIndex) {\r\n    selector(el).querySelector('.is--active').classList.remove('is--active')\r\n    selector(el)\r\n      .querySelector(`.bullet:nth-of-type(${splide.index + 1})`)\r\n      .classList.add('is--active')\r\n  })\r\n}\r\nexport function connectSplideCarouselBullets(splide, el) {\r\n  const slider$ = splide.root\r\n  const pagination$ = selector(el)\r\n  pagination$.parentElement.style.overflow = 'hidden'\r\n\r\n  let pages = 1\r\n  // parse bullets inside the container and repopulate\r\n  function initSate() {\r\n    pages = Math.ceil(splide.length / splide.options.perPage)\r\n\r\n    if (pages > 1) {\r\n      pagination$.parentElement.style.maxHeight = 'revert-layer' // to get the initial css value\r\n\r\n      const bullet$ = pagination$.querySelector('.bullet:not(.is--active)')\r\n\r\n      let fragment = document.createDocumentFragment()\r\n      for (let i = 0; i < pages; i++) {\r\n        let clone$ = bullet$.cloneNode(true)\r\n        clone$.addEventListener('click', (e) => {\r\n          splide.go('>' + i)\r\n        })\r\n        fragment.appendChild(clone$)\r\n      }\r\n      fragment.firstChild.classList.add('is--active')\r\n      pagination$.replaceChildren(fragment)\r\n    } else {\r\n      // keep the dom elements to repopulate in the future\r\n      pagination$.parentElement.style.maxHeight = '0px'\r\n    }\r\n  }\r\n  function initBullets(newIndex = splide.index) {\r\n    const index = Math.ceil(newIndex / splide.options.perPage)\r\n\r\n    pagination$.querySelector('.is--active')?.classList.remove('is--active')\r\n    pagination$.querySelector(`.bullet:nth-of-type(${index + 1})`)?.classList.add('is--active')\r\n  }\r\n\r\n  splide.on('mounted resized ', function () {\r\n    initSate()\r\n    splide.go(0)\r\n    // updateBullets()\r\n  })\r\n  splide.on('move ', function (newIndex, oldIndex) {\r\n    if (pages < 2) return\r\n    // const index = splide.Components.Controller.toPage(splide.index) // works but the calculation can be wrong as the bullets are manually added\r\n    initBullets(newIndex)\r\n  })\r\n}\r\n\r\nexport function splideAutoWidth(splide) {\r\n  // if not enough logos it will center them and stop the slider\r\n  const Components = splide.Components\r\n  // to remove duplicates for inactive/small slider\r\n  splide.on('overflow', function (isOverflow) {\r\n    splide.go(0) // Reset the carousel position\r\n\r\n    splide.options = {\r\n      focus: isOverflow ? 'center' : '',\r\n      drag: isOverflow ? 'free' : false,\r\n      clones: isOverflow ? undefined : 0, // Toggle clones\r\n    }\r\n  })\r\n  let sliderOverflow = true\r\n  let sliderReady = false\r\n  // to center inactive/small slider\r\n  splide.on('resized', function () {\r\n    var isOverflow = Components.Layout.isOverflow()\r\n    sliderOverflow = isOverflow\r\n    var list = Components.Elements.list\r\n    var lastSlide = Components.Slides.getAt(splide.length - 1)\r\n\r\n    if (lastSlide) {\r\n      // Toggles `justify-content: center`\r\n      list.style.justifyContent = isOverflow ? 'flex-start' : 'center'\r\n\r\n      // Remove the last margin\r\n      if (!isOverflow) {\r\n        lastSlide.slide.style.marginRight = ''\r\n      }\r\n    }\r\n    if (sliderReady) {\r\n      splideInit()\r\n    }\r\n  })\r\n  splide.on('mounted', splideInit)\r\n  function splideInit() {\r\n    sliderReady = true\r\n    if (!sliderOverflow) {\r\n      splide.Components.AutoScroll.pause()\r\n    } else if (sliderOverflow && splide.Components.AutoScroll.isPaused()) {\r\n      // } else if (sliderOverflow && splide.Components.AutoScroll?.isPaused()) {\r\n      splide.Components.AutoScroll.play()\r\n    }\r\n  }\r\n}\r\n\r\nexport function onDomReady(run) {\r\n  if (document.readyState !== 'loading') {\r\n    run()\r\n  } else {\r\n    document.addEventListener('DOMContentLoaded', function () {\r\n      run()\r\n    })\r\n  }\r\n}\r\n\r\n// Add an observer that checks if a class exists. If it does remove the observer and call a function\r\nexport function addObserver(element, className, callback) {\r\n  const observer = new MutationObserver(function (mutations) {\r\n    mutations.forEach(function (mutation) {\r\n      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\r\n        observer.disconnect()\r\n        callback()\r\n      }\r\n    })\r\n  })\r\n  observer.observe(element, {\r\n    attributes: true,\r\n    attributeFilter: ['class'],\r\n  })\r\n}\r\n\r\n// run a callback on change with the delay, if another change occurs before the delay, the timer resets\r\nexport function initObserver(element$, timeout = 100, observerName = 'default', callback) {\r\n  if (element$?.observer?.[observerName]) return\r\n  let timerId = 0\r\n\r\n  const observer = new MutationObserver(function (mutations) {\r\n    clearTimeout(timerId)\r\n    timerId = setTimeout(() => {\r\n      // console.log(observerName, element$)\r\n      callback()\r\n      // observer.disconnect()\r\n    }, timeout)\r\n  })\r\n\r\n  observer.observe(element$, { childList: true, attributes: true })\r\n  element$.observer = element$.observer || {}\r\n  element$.observer[observerName] = observer\r\n}\r\n\r\n// run one callback when class is added and another when it is removed\r\nexport function classAddedRemovedObserver(element, className, addedCallback, removedCallback) {\r\n  const element$ = selector(element)\r\n\r\n  const observer = new MutationObserver((mutations) => {\r\n    mutations.forEach((mutation) => {\r\n      if (mutation.type === 'attributes' && mutation.attributeName === 'class') {\r\n        const classList = mutation.target.classList\r\n        if (classList.contains(className)) {\r\n          addedCallback()\r\n          // console.log('Class ' + className + ' added')\r\n        } else {\r\n          removedCallback()\r\n          // console.log('Class ' + className + ' removed')\r\n        }\r\n      }\r\n    })\r\n  })\r\n\r\n  observer.observe(element$, { attributes: true })\r\n}\r\n\r\nimport gsap from 'gsap'\r\nimport { ScrollTrigger } from 'gsap/ScrollTrigger'\r\n\r\nexport function scrollTriggerInit(distance = 0, elClassName = '', sectionClassName = '', fromToType = '', topMiddleBottom = '', markers = false) {\r\n  const tlType = fromToType === '' ? 'fromTo' : fromToType\r\n  const stPosition = topMiddleBottom === '' ? 'middle' : topMiddleBottom\r\n  // negative distance = front object (faster on scroll), positive distance = back object (slower on scroll/more sticky)\r\n  const tl = gsap.timeline({ defaults: { ease: 'none' } })\r\n  if (tlType === 'fromTo') {\r\n    let fromDistance = -distance,\r\n      toDistance = distance\r\n    // remove the minus sign in a string for fromDistance\r\n    if (typeof distance === 'string' && distance.charAt(0) === '-') fromDistance = distance.substring(1)\r\n\r\n    tl.fromTo('.' + elClassName, { y: fromDistance }, { y: toDistance })\r\n  } else if (tlType === 'to') {\r\n    tl.to('.' + elClassName, { y: distance })\r\n    console.log('to')\r\n  } else if (tlType === 'from') {\r\n    console.log('from')\r\n    tl.from('.' + elClassName, { y: distance })\r\n  }\r\n\r\n  let start = 'top bottom'\r\n  let end = 'bottom top'\r\n  if (stPosition === 'top') {\r\n    start = 'top top'\r\n  } else if (stPosition === 'bottom') {\r\n    end = 'bottom bottom'\r\n  }\r\n\r\n  sectionClassName = sectionClassName || elClassName\r\n  return ScrollTrigger.create({\r\n    animation: tl,\r\n    trigger: '.' + sectionClassName,\r\n    start: start,\r\n    end: end,\r\n    markers: markers,\r\n    scrub: true,\r\n    delay: 0.0,\r\n  })\r\n}\r\n\r\nexport function addSwiperClasses(slider) {\r\n  const swiper = document.querySelector('.' + slider)\r\n  const list = swiper.children[0]\r\n  const slide = list.childNodes\r\n  swiper.classList.add('swiper')\r\n  list.classList.add('swiper-wrapper')\r\n  slide.forEach((slide) => slide.classList.add('swiper-slide'))\r\n}\r\n\r\nexport function getSiblings(e) {\r\n  let siblings = []\r\n  // if no parent, return no sibling\r\n  if (!e.parentNode) {\r\n    return siblings\r\n  }\r\n  // first child of the parent node\r\n  let sibling = e.parentNode.firstChild\r\n  // collecting siblings\r\n  while (sibling) {\r\n    if (sibling.nodeType === 1 && sibling !== e) {\r\n      siblings.push(sibling)\r\n    }\r\n    sibling = sibling.nextSibling\r\n  }\r\n  return siblings\r\n}\r\n\r\nexport function getLineNum(el) {\r\n  const textarea = el\r\n  // console.log('textarea', textarea)\r\n\r\n  const parseValue = (v) => (v.endsWith('px') ? parseInt(v.slice(0, -2), 10) : 0)\r\n\r\n  const calculateNumLines = (str) => {\r\n    const textareaStyles = window.getComputedStyle(textarea)\r\n    const font = `${textareaStyles.fontSize} ${textareaStyles.fontFamily}`\r\n    const paddingLeft = parseValue(textareaStyles.paddingLeft)\r\n    const paddingRight = parseValue(textareaStyles.paddingRight)\r\n    const textareaWidth = textarea.getBoundingClientRect().width - paddingLeft - paddingRight\r\n    // console.log(textareaWidth, font)\r\n\r\n    const canvas = document.createElement('canvas')\r\n    const context = canvas.getContext('2d')\r\n    context.font = font\r\n\r\n    const words = str.split(' ')\r\n    let lineCount = 0\r\n    let currentLine = ''\r\n    for (let i = 0; i < words.length; i++) {\r\n      const wordWidth = context.measureText(words[i] + ' ').width\r\n      const lineWidth = context.measureText(currentLine).width\r\n\r\n      if (lineWidth + wordWidth > textareaWidth) {\r\n        lineCount++\r\n        currentLine = words[i] + ' '\r\n      } else {\r\n        currentLine += words[i] + ' '\r\n      }\r\n    }\r\n\r\n    if (currentLine.trim() !== '') {\r\n      lineCount++\r\n    }\r\n\r\n    return lineCount\r\n  }\r\n  return calculateNumLines(el.textContent)\r\n  // return el.value.split('\\n').length\r\n}\r\n\r\nexport function wfSliderArrows() {\r\n  const arrows$a = selAll('[slider-arrows]')\r\n  arrows$a.forEach((el) => {\r\n    const providedSelector = el.getAttribute('slider-arrows')\r\n    const placedInside = !providedSelector && providedSelector === ''\r\n\r\n    const slider$ = placedInside ? el.closest('.w-slider') : selector(providedSelector)\r\n    // if (slider$.arrowsAttached) return\r\n    // stop if invoked by arrows from within 2nd time, the arrows are connected already\r\n    if (slider$.hasAttribute('arrows-attached') && placedInside) return\r\n\r\n    const wfLeftArrow$ = slider$.querySelector('.w-slider-arrow-left')\r\n    const wfRightArrow$ = slider$.querySelector('.w-slider-arrow-right')\r\n    const customLeftArrow$a = slider$.querySelectorAll('.arrow.is--left')\r\n    const customRightArrow$a = slider$.querySelectorAll('.arrow:not(.is--left)')\r\n    customLeftArrow$a.forEach((el) => {\r\n      el.addEventListener('click', function () {\r\n        wfLeftArrow$.click()\r\n      })\r\n    })\r\n    customRightArrow$a.forEach((el) => {\r\n      el.addEventListener('click', function () {\r\n        wfRightArrow$.click()\r\n      })\r\n    })\r\n    // slider$.arrowsAttached = true\r\n    if (placedInside) slider$.setAttribute('arrows-attached', '')\r\n  })\r\n}\r\n\r\nexport function wfTabs() {\r\n  const customTabs$a = selAll('[tabs-nav]')\r\n  customTabs$a.forEach((customTabs) => {\r\n    const providedSelector = customTabs.getAttribute('tabs-nav')\r\n    const placedInside = !providedSelector && providedSelector === ''\r\n    const tabs$ = placedInside ? customTabs.closest('.w-tabs') : selector(providedSelector)\r\n    // stop if invoked by tabs from within 2nd time, all tabs are connected already\r\n    if (tabs$.hasAttribute('tabs-attached') && placedInside) return\r\n\r\n    const customTabs$a = customTabs.querySelectorAll('a')\r\n    customTabs$a.forEach((customTabsTab, i) => {\r\n      customTabsTab.addEventListener('click', function () {\r\n        customTabs.querySelectorAll('.is--active').forEach((el) => el.classList.remove('is--active'))\r\n        customTabsTab.classList.add('is--active')\r\n        const wfTab = tabs$.querySelector('[id$=\"-data-w-tab-' + i + '\"]')\r\n        wfTab.click()\r\n      })\r\n    })\r\n    tabs$.setAttribute('tabs-attached', '')\r\n  })\r\n}\r\n"
        }
    ]
}